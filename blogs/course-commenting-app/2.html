<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Course Commenting App</title>
    <meta name="description" content="Blog description">
    <link rel="stylesheet" href="../blog.css">

    <!-- File tree styling -->
    <script src="../../scripts/fileTree/fileTree.js"></script>
    <link rel="stylesheet" href="../../scripts/fileTree/styles.css">

    <!-- JS Code Highlighting CDNS -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-okaidia.min.css">

    <!-- Additional styles for the folder structure -->
    <script>
        const folderUrl = "../images/other/folder.svg"
        const fileUrl = "../images/other/file.svg"
        const rootProjectFolder = {
            name: "Course Commenting Web App",
            fileContents: [
                {
                    name: "frontend",
                    fileContents: []
                }, {
                    name: "backend",
                    fileContents: []
                }
            ]
        }
        const backendFolder = {
            name: "backend",
            fileContents: [{
                name: "node_modules",
                fileContents: []
            }, {
                name: "package.json"
            }, {
                name: "package-lock.json"
            }, {
                name: "index.js",
                highlight: true
            }]
        }
        const frontendIndex = {
            name: "frontend",
            fileContents: [{
                name: "node_modules",
                fileContents: []
            }, {
                name: "public",
                fileContents: []
            }, {
                name: "src",
                fileContents: [{
                    name: "App.css"
                }, {
                    name: "App.js",
                    highlight: true,
                }, {
                    name: "...others"
                }]
            }, {
                name: ".gitignore"
            }, {
                name: "package-lock.json"
            }, {
                name: "package.json"
            }, {
                name: "README.md"
            }]
        }
    

        document.addEventListener("DOMContentLoaded", ()=>{
            createFileTree(document.querySelectorAll("div.root-project-folder"), rootProjectFolder)
            createFileTree(document.querySelectorAll("div.express"), backendFolder)
            createFileTree(document.querySelectorAll("div.react-appjs"), frontendIndex)
        })
    </script>
</head>
<body>
    <div id="content">
        <div id="top-shading">
            <a href="../../index.html#blog">< Back</a>
        </div>
        <section>
            <h1>Course Commenting Web App - Setting up SQLite</h1>
            <!-- Started on 15 April 2024 -->
            <p>15 April 2024</p>
            <br>
            <h4>Access the project on:</h4>
            <a href="">Github</a>
            <br>
            <nav>
                <p>List of Contents: </p>
                <ul>
                    <li><a href="#introduction">Introduction</a></li>
                    <li><a href="#react">Setting up ReactJS</a></li>
                    <li><a href="#express">Setting up NodeJS and ExpressJS</a></li>
                    <li><a href="#restapi">Simple REST API</a></li>
                    <li><a href="#frontend">Making the UI</a></li>
                </ul>
            </nav>
        </section>

        <!-- Introduction -->
        <section>
            <h2 id="introduction">Introduction</h2>
            <p>
                This series will provide a tutorial on making a full stack web app with 
                <a href="https://react.dev/">ReactJS</a> for the frontend and 
                <a href="https://expressjs.com/">ExpressJS with NodeJS</a> for the backend.
                Finally, we will use <a href="https://www.sqlite.org/">SQLite</a> for the database.
                The web app we make will be a simple basic anonymous commenting app which will roughly
                demonstrate how a full stack web app will generally be structured, 
                at least how I usually do it, which I also hope to be the generally correct way.
                
                <br>
                I suppose this series will assume some familiarity with Javascript, but it shouldn't be
                necessary to have prior experience with the other tools. I would highly recommend watching these videos
                to get an idea of what these things does: 
            </p>
            <ul>
                <li><a href="https://www.youtube.com/watch?v=ENrzD9HAZK4">NodeJS</a></li>
                <li><a href="https://www.youtube.com/watch?v=Tn6-PIqc4UM">ReactJS</a></li>
                <li><a href="https://www.youtube.com/watch?v=-MTSQjw5DrM">ExpressJS and REST APIs</a></li>
                <li><a href="https://www.youtube.com/watch?v=zsjvFFKOm3c">SQL</a></li>
                <li>Generally other of his videos</li>
            </ul>
            <p>
                I will link many documentation links along this guide. It is highly recommended to check out 
                these documentation to learn more about what actually happens.
                I don't explain much details as I don't really know it myself until I read the documentation.
                I plan for this guide to give an overview anyways, and to act as a starting point for exploration.
            </p>

            <p>
                Before starting the project, do make sure that <a href="https://nodejs.org/en/download">NodeJS</a> is installed 
                and make sure <a href="https://www.npmjs.com/">npm</a> (Node Package Manager) is available in your system. 
            </p>
        </section>

        <!-- React -->
        <section>
            <h2 id="react">Setting up React</h2>
            <p>
                Let us start by setting up the frontend side. In your project root folder, make 2 folders
                for the frontend and backend. 
            </p>

            <figure>
                <div class="root-project-folder"></div>
                <figcaption>File Structure</figcaption>
            </figure>
            
            <p>
                We will now install ReactJS in the FrontEnd folder. To do this, run the following.
            </p>

            <figure>
                <pre style="white-space: pre;"><code class="language-sh">npx create-react-app ./
npm start</code></pre>

                <figcaption>Setting up ReactJS</figcaption>
            </figure>

            <p>
                You should now be able to see the initial ReactJS Screen 🥳
            </p>

            <figure>
                <img src="./images/reactScreen.png" alt="Initial ReactJS Screen">
                <figcaption>If you are having troubles, try reading <a href="https://create-react-app.dev/docs/getting-started">this</a></figcaption>
            </figure>
        </section>
        
        <!-- ExpressJS -->
        <section>
            <h2 id="express">Setting Up NodeJS and ExpressJS</h2>
            <p>
                Next, we will install ExpressJS. First, change your directory to backend. 
                Then, run the following code.
            </p>

            <figure>
                <pre><code class="language-sh">npm init
npm install express</code></pre>
                <figcaption>Read the <a href="https://expressjs.com/en/starter/installing.html">Express documentation</a> for more information. Feel free to fill out the fields as you like.</figcaption>
            </figure>

            <p>
                Then, make a file <code>index.js</code> or any other file name you specified when 
                installing Express in the backend folder and fill in the following.
            </p>

            <figure>
                <div class="express"></div>
                <pre><code class="language-js">const express = require("express")
const app = express()
const port = 3001

app.get("/", (req, res) => {
    res.send("Hello world!")
})

app.listen(port, () => {
    console.log(`Course Commenting Web App BackEnd listening on port ${port}`)
})</code></pre>
            <figcaption>
                Read the <a href="https://expressjs.com/en/starter/hello-world.html">documentation</a> for more info</figcaption>
            </figure>

            <p>
                Also, if you are using git, don't forget to create a <code>.gitignore</code> file
                and write <code>/node_modules</code> in it. Otherwise the entire node module dependency
                folder will be tracked by git, which is usually not what we want.
            </p>

            <p>
                Now, run express by typing in <code class="language-sh p-1">node index.js</code> in the terminal. 
                If you then search <code>http://localhost:3001</code> in a web browser, you should get <code>Hello World</code>.
            </p>
            <p>
                If you change the message and restart the browser, you will observe that the message doesn't change
                unless you rerun the command. To automate this, we can use <code>nodemon</code>.
            </p>
            <figure>
                <pre><code class="language-sh">npm install -g nodemon
npx nodemon index.js</code></pre>
                <figcaption>Read more: <a href="https://www.npmjs.com/package/nodemon">nodemon</a></figcaption>
            </figure>
        </section>

        <section>
            <h2 id="restapi">Simple REST API</h2>
            <p>
                Again, I highly recommend you watch <a href="https://www.youtube.com/watch?v=-MTSQjw5DrM">this video</a>
                to get a feel of what an API is. Right now, we have a single API route in ExpressJS, by doing a
                <code>GET</code> request to the <code>'/'</code> route, the server will respond with <code>'Hello World'</code>.
            </p>
            <p>
                Now we will try to call the API from React. One way to do that is to use the native <code>fetch</code> API provided by browsers.
            </p>

            <figure>
                <div class="react-appjs"></div>
                <pre><code class="language-js">function App(){
    fetch("http://localhost:3001")
        .then(async (res) => {
            console.log(await res.text())
        })
        .catch(err => console.error(err))  
    ...
}</code></pre>
                <figcaption>Read more: <a href="https://react.dev/learn/synchronizing-with-effects#fetching-data"><code>useEffect()</code></a></figcaption>
                <figcaption>Read more: <a href="https://developer.mozilla.org/en-US/docs/Web/API/fetch"><code>fetch()</code></a></figcaption>
                <figcaption>Read more: <a href="https://www.robinwieruch.de/react-hooks-fetch-data/">Fetching data in <code>useEffect()</code></a></figcaption>
            </figure>

            <p>
                This code should fetch data from the backend once when the component is mounted and then
                print it out into the console. However, the console instead prints out this error message.
            </p>

            <figure>
                <code class="language-txt p-4">Access to fetch at 'http://localhost:3001/' from origin 'http://localhost:3000' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. If an opaque response serves your needs, set the request's mode to 'no-cors' to fetch the resource with CORS disabled.</code>
                <figcaption>Watch more: <a href="https://www.youtube.com/watch?v=4KHiSt0oLJ0">CORS</a></figcaption>
            </figure>

            <p>
                CORS is a security policy enforced by the browser. When the server origin is different from the client origin, 
                it will check the server response if it allows the site to receive data from the server.
                Since we haven't set anything in the server, the browser will by default reject the request.
            </p>
            <p>
                So lets now set the CORS policy in ExpressJS.
            </p>

            <figure>
                <pre><code class="language-sh"> npm install cors </code></pre>
                <figcaption>Install <a href="https://expressjs.com/en/resources/middleware/cors.html">
                    Express CORS Middleware
                </a> on the Backend folder</figcaption>
            </figure>
            <figure>
                <div class="express"></div>
                <pre><code class="language-js">...
const cors = require("cors")
...
app.use(cors({origin: "http://localhost:3000"}))
...</code></pre>
                <figcaption>Add CORS headers</figcaption>
            </figure>

            <p>
                If you refresh the React App, you should now see <code>Hello world!</code> in the terminal.
                We have successfully enabled communication between the frontend React app and backend Express app.
            </p>

        </section>
        
        <p>
            Next, we will setup the database.
            Looking at the plugin, it seems we define the database schema with migrations in rust and execute SQL commands from
            the frontend side. Migrations allow us to version control the database schema and make schema changes step by step.
            <br>
            Anyways, since we can call the database from the frontend side by using the plugin, it seems that I will not write too much rust code for this project.
        </p>

        <p>
            To install the plugin, follow the steps <a href="https://github.com/tauri-apps/tauri-plugin-sql">here</a> 👈.
        </p>

        <p>
            Let's start simple for the database, we will make a table to store users or 'Financial Entities'.
        </p>

        <div>
            <table>
                <caption>Users Table Schema</caption>
                <tr>
                    <th>Columns</th>
                    <th>id</th>
                    <th>name</th>
                    <th>created_at</th>
                </tr>
                <tr>
                    <td><b>Data Type</b></td>
                    <td>INTEGER</td>
                    <td>TEXT</td>
                    <td>DATE</td>
                </tr>
                <tr>
                    <td><b>Constraints</b></td>
                    <td>PRIMARY KEY</td>
                    <td>UNIQUE NOT NULL</td>
                    <td>DEFAULT CURRENT_DATE</td>
                </tr>
            </table>
        </div>
        

        <p>
            We do this by adding a Migration in the <code>src-tauri/src/main.rs</code> file.
        </p>
        <figure>
<pre><code class="language-rust">use tauri_plugin_sql::{Migration, MigrationKind};

fn main() {
  let migrations = vec![
    Migration {
      version: 1,
      description: "create_users_table",
      sql: "CREATE TABLE users (
        id INTEGER PRIMARY KEY,
        name TEXT UNIQUE,
        created_at DATE DEFAULT CURRENT_DATE
      )",
      kind: MigrationKind::Up
    }
  ];

  tauri::Builder::default()
    .plugin(
      tauri_plugin_sql::Builder::default()
        .add_migrations("sqlite:database.db", migrations)
        .build()
    )
    .run(tauri::generate_context!())
    .expect("error while running tauri application");
}</code></pre>
        <figcaption><code>src-tauri/src/main.rs</code> - Setting up users table</figcaption>
        </figure>
        


        <h2 id="backend">Communicating with the Database</h2>
        <p>
            Now, we will work on the frontend. We will create a file <code>src/lib/db.ts</code>.
            This typescript file will act as the bridge between the frontend and backend.
            The frontend pages file will access the database by importing functions from <code>src/lib/db.ts</code>.
        </p>

        <p>
            But first, I will declare a <code>User</code> type <small>(you could also use a TS interface)</small> in <code>src/lib/types/db.d.ts</code>. 
            The type will have a similar structure to the previous table schema.
            SQLite stores dates as 'YYYY-MM-DD', and I think when queried into JS, it will become a string, not a Date object,
            so I will set the type of <code>created_at</code> as string.
        </p>
        <figure>
        <pre><code class="language-typescript">export type User = {
    id: number,
    name: string,
    created_at: string
}           </code></pre>
            <figcaption><code>src/lib/types/db.d.ts</code></figcaption>
        </figure>

        <p>
            Now we can write the functions to call the database.
            This file will export a Javascript Object containing the functions to interact with the backend. 
            I plan for the <code>getUsers()</code> function to only select the id and name columns, 
            so the returned object will only be the id and name part of the <code>User</code> type.
        </p>
        <figure>
            <pre><code class="language-typescript">import Database from "tauri-plugin-sql-api"
import type { User } from './types/db'

const _db = await Database.load("sqlite:database.db")

async function getUsers() : Promise&lt;Pick&lt;User, "id" | "user"&gt;&gt; {
    return _db.select(
        "SELECT id, name FROM users"
    )
}

async function addUser(name: string) : Promise&lt;void> {
    _db.execute(
        "INSERT INTO users (name) VALUES (?)",
        [name]
    )
}

const db = {
    getUsers, addUser
}

export default db</code></pre>
            <figcaption><code>src/lib/db.ts</code></figcaption>
        </figure>
        <p>
            Usually when making a web app, the backend or web server will query the database whereas the client would do a <code>fetch</code>
            call to an API route. However, the Tauri SQL plugin lets us call the database directly from the frontend JS side and 
            I think it should be fine since both processes run on the local computer, unlike the web where the client and server are different computers.
            It is also possible to query the db in the Rust side, then use <a href="https://tauri.app/v1/references/architecture/inter-process-communication/">Tauri IPC</a>, which I view as the web API equivalent of Tauri
            in that it allows for communcation between the frontend and backend.

        </p>
        <p>
            Right now, the code is pretty basic and I haven't added any error handling of some sort.
            I'm thinking that the frontend would handle the error by calling <code>.catch()</code> on the promise.
            Even if it isn't catched, the error message would just end up being printed out into the console anyways.
            Perhaps later on, we could change the error message here to make it more user friendly.
        </p>
        <p>
            In <code>addUser()</code>, the <code>_db.execute()</code> actually returns an object when called, but I don't think that it is that important,
            so I didn't return the promise.
        </p>

        <h2 id="frontend">User Interface</h2>
        <p>
            Finally, to finish this functionality of adding a user, we create the user interface. 
            In the opening screen, I will add a button to create a new user and a list of buttons to select existing users.
            Below, I provide the main parts of the frontend code.
        </p> 
            
        <figure>
            <img src="./images/personal-financial-accountant/opening-screen.png" alt="">
            <pre><code class="language-html">&lt;script>
    import db from "$lib/db"
    import type { User } from '$lib/types/db'
    import { user } from '$lib/stores'
    
    let users : Pick&lt;User, "id" | "name"> = []
    
    db.getUsers()
        .then(data => { users = data })
    
    const setUser = () => {user.set()}
&lt;/script>
...
&lt;a href="./createUser">Create new User&lt;/a>
<!-- {#each users as {id, name}} -->
&lt;a href="./dashboard" 
    on:click={function(){user.set({id, name})}} 
    >
    {name}
    &lt;/a>
{/each}</code></pre>
            <figcaption><code>src/routes/createUser/+page.svelte</code></figcaption>
        </figure>
            
        <p>
            The forms to create a new user will be on another file.
            When the user is first created, I want it to be possible to add extra configuration,
            so I use the <code>Stepper</code> UI component from SkeletonUI to display the multi step form.
        </p>

        <p>
            The .svelte file will contain some input tags whose values binds to an object.
            This object will be passed to the <code>addUser</code> function.
        </p>

        <figure>
            <img src="./images/personal-financial-accountant/input-user.png" alt="">
            <pre><code class="language-html">&lt;script>
    import db from '$lib/db'
    let user = {
        name: '',
        // Gets current date in YYYY-MM-DD
        date: (new Date()).toISOString().slice(0, 10)
    }

    function submit() {
        db.addUser(user.name, user.date)
    }
&lt;/script>
...
&lt;input type="text" bind:value={user.name}/>
&lt;input type="date" bind:value={user.date}/>
&lt;button on:click={submit} /></code></pre>
            <figcaption><code>src/routes/createUser/+page.svelte</code></figcaption>
        </figure>

        <p>There you go, we have created a tauri app that can create a user and store it in a SQLite database.</p>

        <a href="personal-accountant-tauri/2.html">Next page ⏭️</a>
    </div>
</body>
</html>